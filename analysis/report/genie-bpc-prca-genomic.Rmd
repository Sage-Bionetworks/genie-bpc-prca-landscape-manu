---
title: "BPC Prostate - Genomic descriptives"
author: "Alex Paynter"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, include = F,
                      warning = F, message = F,
                      fig.width = 7, fig.height = 5)
k_dpi <- 150
pal_pt_hc <- c("#004488","#ddaa33", "#bb5566")
```

<style type="text/css">
.main-container {
  max-width: 1000px !important;
  margin: auto;
}
</style>

```{r}
library(purrr)
library(here)
library(fs)

purrr::walk(.x = fs::dir_ls(here('R')), .f = source) # also loads lots of packages.
```



```{r, set_gtsummary_theme}
theme_gtsummary_compact()
theme_gtsummary_language("en", big.mark = "") # for now.


```


```{r, warning = T}
read_wrap_clin <- function(p) {
  read_rds(file = here("data", 'clin', p))
}

dft_pt <- read_wrap_clin("dft_pt.rds")
dft_ca_ind <- read_wrap_clin("dft_ca_ind.rds")
# we're taking the augmented version, which has TMB columns added.  The existing info is the same.
dft_cpt <- read_wrap_clin("dft_cpt_aug.rds")

read_wrap_geno <- function(p) {
  read_rds(file = here("data", 'genomic', p))
}

dft_gp_all <- read_wrap_geno('gene_panel_all.rds')
dft_gp_sum <- read_wrap_geno('gene_panel_sum.rds')
dft_gp_by_gene <- read_wrap_geno('gene_panel_by_gene.rds')
dft_onco_impact <- read_wrap_geno('oncokb_impact.rds')

dft_alt <- read_wrap_geno('alterations.rds')

dft_gt_any_alt <- read_wrap_geno(
  'gene_test_any_alt.rds'
)


```


## Content


```{r}
# Table explaining the sample type coding we'll use:
dfp_sample_type_expl <- dft_cpt %>% 
  group_by(sample_type) %>%
  summarize(
    num_sample = n(),
    # Each group should have one unique sample_type_simple_f - but if not this will fail loudly in the table. 
    coded_as = paste(unique(sample_type_simple_f)),
    .groups = "drop"
  ) %>%
  arrange(desc(num_sample))

# pp = per person.
dft_ngs_pp <- dft_cpt %>%
  group_by(record_id) %>%
  summarize(
    All = n(),
    Primary = sum(sample_type_simple_f %in% "Primary tumor"),
    Metastatic = sum(sample_type_simple_f %in% "Metastatic")
  ) 

dft_ngs_pp_long <- dft_ngs_pp %>%
  pivot_longer(
    cols = -record_id,
    names_to = "category",
    values_to = "count"
  ) %>%
  mutate(
    category = forcats::fct_inorder(category)
  )

gg_ngs_pp <- ggplot(
  data = dft_ngs_pp_long,
  aes(x = count, fill = category)
) + 
  geom_histogram(binwidth = 1, center = 0) +
  theme_classic() + 
  labs(x = "Number of tests",
       y = "Participants") + 
  scale_y_continuous(expand = expansion(add = 0, mult = c(0,0.05)),
                     n.breaks= 8) +
  scale_x_continuous(
    breaks = 0:10,
    expand = expansion(
      add = c(0,0), 
      mult = c(0,0.01)
    )
  ) + 
  facet_wrap(vars(category)) +
  theme(
    strip.text = element_text(hjust = 0),
    legend.position = "none"
  ) + 
  scale_fill_manual(
    values = pal_pt_hc
  )

n_prim_met_pair <- dft_ngs_pp %>% 
  filter(Primary >= 1 & Metastatic >= 1) %>%
  nrow(.)

n_gte_2_prim <- dft_ngs_pp %>% 
  filter(Primary >= 2) %>%
  nrow(.)

n_gte_2_met <- dft_ngs_pp %>% 
  filter(Metastatic >= 2) %>%
  nrow(.)
                            
```


### R2.1.1 NGS tests per person

This table uses the "Specimen Sample Type" variable from the Cancer Panel Test dataset.  We simplified this slightly (`coded_as`) to avoid small categories of tumors:

```{r, include = T}
dfp_sample_type_expl %>%
  huxtable(.) %>%
  huxtable::set_align(value = "left") %>%
  theme_compact(.)
```

The following plot shows histograms of the number of tests per participant.  This is repeated for all tests (Primary, Metastatic, Other) and separately for Primary and Metastatic tumors.

```{r, include = T, fig.height = 3}
gg_ngs_pp
```

Observations:

- The overwhelming majority of participants have exactly one NGS test.
- About 400 people have no primary tumor tests at all.
- `r n_prim_met_pair` people have at least one primary and at least one metastatic tumor.
- Only `r n_gte_2_prim` participants have more than one primary tumor test.
- There are `r n_gte_2_met` with more than one metastatic test, overwhelmingly from MSK.










```{r}
gg_gene_sample_hist <- ggplot(
  dft_gp_by_gene,
  aes(x = prop_samp_tested)
) +
  geom_histogram(binwidth = 0.1, center = 0.05, fill = '#6699cc') +
  theme_classic() + 
  labs(x = "Proportion of samples gene tested in",
       y = "Number of genes") + 
  scale_y_continuous(expand = expansion(add = 0, mult = c(0,0.05)),
                     n.breaks= 8) +
  scale_x_continuous(
    labels = scales::percent,
    expand = expansion(add = c(0,0), mult = c(0,0.01)),
    breaks = seq(0,1, by = 0.1)) + 
  theme(
    # jump up the right margin to get the '100%' in 
    plot.margin = margin(unit(c(5.5, 10, 5.5, 5.5), "points"))
  )

# Quick computation for the observations below:
n_genes_total_coverage <- dft_gp_by_gene %>% filter(prop_samp_tested >= 0.999) %>% nrow()
n_genes_90_cov <- dft_gp_by_gene %>% filter(prop_samp_tested >= 0.899) %>% nrow()
n_genes_70_cov <- dft_gp_by_gene %>% filter(prop_samp_tested >= 0.699) %>% nrow()
dft_gp_by_gene %>% filter(prop_samp_tested < 0.5) %>% nrow()

```

### R2.1.2 Gene NGS coverage over samples

There are `r length(unique(dft_gp_by_gene$hugo))` genes covered by at least one panel in this dataset.  This is a histogram of genes, showing the number covering each decile of the proportion of samples (see example interpretation below).

```{r, include = T, fig.height = 4}
gg_gene_sample_hist
```

**Example interpretation:** The bar between 90% and 100% shows about 200 genes.  This means that approximately 200 genes were covered in at least 90% of panels.  Likewise, there were nearly 300 genes which were covered in under 10% of samples.

Observations:

- There are only `r n_genes_total_coverage` genes covered by every panel.  For our clinico-genomic analyses analyses it might be better to include genes covered by **most** panels to gather a larger set.  Two natural cut points based on the graph above may be:
  - Genes covered by at least 90% of panels: `r n_genes_90_cov`.
  - Genes covered by at least 70% of panels: `r n_genes_70_cov`.
  - Keep in mind that some of these will have too few positives to be used, further reducing the numbers of genes included.  We'll describe this in subsequent sections.
- The majority of genes are covered by under 50% of samples.  These will almost certainly need to be excluded for clinico-genomic analyses due to the degree of missingness.








```{r}
# Add the number of patients and samples in parens:
dft_gp_all %<>%
  arrange(cpt_seq_assay_id) %>%
  left_join(
    ., 
    select(dft_gp_sum, cpt_seq_assay_id, n_pts, n_samples, n_genes),
    by = "cpt_seq_assay_id"
  ) %>%
  mutate(
    assay_lab = glue("{cpt_seq_assay_id} [{n_genes}] ({n_pts}, {n_samples})"),
    assay_lab = forcats::fct_inorder(assay_lab)
  ) 

# Get the list of genes covered in >50% of samples and which have at least 1 alteration in the data:

vec_gene_gte1_alt <- readr::read_rds(
  here('data', 'genomic', 'gene_gte1_alt.rds')
)
dft_gene_prop_samp_test <- readr::read_rds(
  here('data', 'genomic', 'gene_prop_samp_test.rds')
)
vec_test_prop_gte50 <- dft_gene_prop_samp_test %>%
  filter(prop >= 0.5) %>%
  pull(hugo)
dft_gp_all_limited <- dft_gp_all %>%
  filter(hugo %in% vec_gene_gte1_alt) %>%
  filter(hugo %in% vec_test_prop_gte50)


gg_panel_coverage <- plot_assay_heatmap(
  dat = dft_gp_all,
  plot_title = "Gene panel coverage"
)

gg_panel_coverage_limited <- plot_assay_heatmap(
  dat = dft_gp_all_limited,
  plot_title = "Gene panel coverage (limited)"
)
  
  
  
```


### R2.1.3a Panel coverage

Heatmap of gene panel coverage.

```{r, include = T, fig.width = 10, fig.height = 5}
gg_panel_coverage
# Technically this works but it takes too long:
# plotly::ggplotly(gg_panel_coverage)
```

Observations:

- Panels vary in size considerably (under 50 to over 500). 
- Currently this figure is order by number of patients on the Y axis.  It might be more informative to cluster the axis by similarity.  Some obvious groups of panels jump out to me:
  - {DFCI-ONCOPANEL-3, DFCI-ONCOPANEL-3.1, UNH-555-*}
  - {MSK_IMPACT468, DFCI-ONCOPANEL-2, VICC-01-T7}
  - The two UHN panels with few genes covered. 







```{r}
n_pt <- dft_ca_ind %>% nrow
n_samp <- dft_cpt %>% nrow

gene_panel_table_help <- function(dat) {
  dat %>% 
    mutate(
      Patients = glue("{n_pts} ({round(n_pts/n_pt*100, 1)}%)"),
      Samples = glue("{n_samples} ({round(n_samples/n_samp*100, 1)}%)"),
      Genes = n_genes
    ) %>%
    select(
      Panel = cpt_seq_assay_id,
      Patients,
      Samples,
      Genes
    ) %>%
    distinct
}

dfp_gp <- gene_panel_table_help(dft_gp_all)
dfp_gp_limited <- gene_panel_table_help(dft_gp_all_limited)

gp_table_hux <- function(dat) {
  dat %>%
    huxtable(.) %>%
    huxtable::set_align(value = "left") %>%
    theme_compact(.)
}
  
```

**Table Version**  The following table shows similar information to the above figure: the number of patients, samples and genes covered by each panel.  

```{r, include = T}
gp_table_hux(dfp_gp)
```

*Note:* The patient percentages do not add to 100 (because each person can be tested with multiple panels).



```{r}
genes_panel <- dft_gp_all %>% 
  pull(hugo) %>% 
  unique %>%
  length


genes_panel_limited <- dft_gp_all_limited %>% 
  pull(hugo) %>% 
  unique %>%
  length
```


### R2.1.3b Panel coverage, limited

Same as R2.1.2a except we limit to genes with at least one alteration in the dataset, and genes that are covered in the panels used in at least 50% of samples.  This selection brings us down to `r genes_panel_limited` genes, from the original `r genes_panel`.

```{r, show_gene_figure_limited, include = T}
gg_panel_coverage_limited
```

The table version of the limited set above would be the same except for the `Genes` column.  Skipping for now.









```{r, include = T}
gg_onco_impact <- plot_alt_onco_impact(
  dft_onco_impact,
  y_var = "type"
)
```




```{r}
dft_alt %>% 
  count(sample_id, sort = T) %>% 
  ggplot(
    aes(x = n)
  ) + 
  geom_histogram() + 
  theme_bw()

```


### R2.2.1 Alterations per sample

All I want to showcase here is that there are a few samples with dozens of alterations, and most samples have few to none (this plot does not include samples with zero alterations, but those can be added in).

```{r, include = T, fig.height = 3}
gg_alt_dist <- dft_alt %>% 
  count(sample_id, sort = T) %>% 
  ggplot(
    aes(x = n, y = 1)
  ) + 
  geom_jitter(width = 0, height = 1) + 
  theme_classic() + 
  labs(
    title = "Number of alterations in each sample",
    subtitle = "One dot is one sample",
    x = "Number of Alterations"
  ) +
  theme(
    plot.title.position = "plot",
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank()
  ) + 
  scale_x_continuous(
    expand = expansion(mult = 0.01, add = 0)#,
    # trans = 'log10'
  )

gg_alt_dist

```




```{r}

dft_cpt_known_type <- dft_cpt %>%
  filter(sample_type_simple_f %in% c("Primary tumor", "Metastatic"))
# This is added to the version of the CPT data we loaded, so we don't need to do any calculations.
gg_tmb_dist <- ggplot(
  data = dft_cpt_known_type,
  aes(x = tmb_Mb + 0.1, y = 1)
) + 
  stat_boxplot(outlier.shape = NA, coef = Inf) + 
  geom_jitter(width = 0, height = 0.3, alpha = 0.3) + 
  theme_classic() + 
  labs(
    title = "Tumor mutation burden sample distribution",
    subtitle = "0.1 added to all, whiskers go to max/min",
    x = "TMB (mutations per megabase)"
  ) +
  theme(
    plot.title.position = "plot",
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank()
  ) + 
  scale_x_continuous(
    expand = expansion(mult = 0.01, add = 0),
    trans = 'log10'
  ) +
  facet_wrap(vars(sample_type_simple_f), ncol = 1) 

prop_over_tmb_10 <- dft_cpt %>%
  filter(tmb_Mb >= 10) %>%
  nrow(.) %>%
  divide_by(nrow(dft_cpt))

```

### R2.3.1 TMB distribution

A plot showing the tumor mutation burden for each sample in mutations per megabase.  Notes:

- The panel size (denominator for TMB) is the width of the union of all exons covered by each panel, as determined by the bed files submitted by each site.
- Panel-derived TMB is known to be an imperfect predictor of exomic TMB (https://doi.org/10.1158/2767-9764.CRC-22-0339).
- Each TMB in the plot below has a small amount added (0.1). This allows the inclusion of 0 TMB samples while using a log scale.

```{r print_tmb, include = T, fig.height = 3}
gg_tmb_dist
```

Notes:

- `r round(prop_over_tmb_10*100,1)`% of the samples in this dataset have a TMB greater than 10 mut/Mb.  This is the pre-specified threshold we hoped to use for hypermutated samples in later analyses.










```{r}
dft_tmb <- dft_cpt_known_type |>
  group_by(cpt_seq_assay_id) |> 
  mutate(n_this_panel = n()) |>
  ungroup() |>
  filter(n_this_panel >= 5) |>
  group_by(cpt_seq_assay_id, sample_type_simple_f) |>
  mutate(n_this_panel_type = n()) |>
  ungroup() |>
  mutate(
    panel_lab = factor(
      paste0(cpt_seq_assay_id, " (n=", n_this_panel_type, ")")
    )
  )

gg_tmb_dist_panel <- ggplot(
  data = dft_tmb,
  aes(
    x = tmb_Mb + 0.1, 
    y = panel_lab,
    fill = institution
  )
) + 
  stat_boxplot(outlier.shape = NA, coef = 100) + 
  # geom_jitter(width = 0, height = 1) + 
  theme_classic() + 
  labs(
    title = "Tumor mutation burden sample distribution",
    subtitle = "+0.1 added to all, boxplot whiskers go to max/min",
    x = "TMB (mutations per megabase)"
  ) +
  theme(
    plot.title.position = "plot",
    axis.title.y = element_blank(),
    axis.text.y = element_text(hjust = 0),
    strip.text = element_text(hjust = 0)
  ) + 
  scale_x_continuous(
    expand = expansion(mult = 0.01, add = 0),
    trans = 'log10'
  ) +
  scale_y_discrete(limits=rev) + 
  guides(fill = "none") + 
  facet_wrap(
    vars(sample_type_simple_f), 
    ncol = 1,
    scales = "free"
  ) + 
  coord_cartesian(
    xlim = c(NA, max(dft_tmb$tmb_Mb + 0.2))
  ) + 
  scale_fill_vibrant()

```

### R2.3.2 TMB by panel

In our Dec 2023 meeting there was consensus that the TMB distribution above seemed to have an excess number of individuals with high TMB.  One reason for this may be that most GENIE sites have tumor only sequencing.  Even with the efforts to remove germline mutations, some could slip through, artificially inflating the TMB of those samples.

Fortunately we have one large site which uses tumor-normal sequencing (MSK).  If the germline mutations are indeed the cause of the high TMB in our group, we would expect the MSK panels to have a more typical TMB distribution and the others to be relatively high.  This motivates the next plot, where we show TMB distributions by panel (panels with less than 5 samples were removed):


```{r, include = T}
gg_tmb_dist_panel
```






```{r}
gg_tmb_ecdf_panel <- ggplot(
  data = dft_tmb,
  aes(
    x = tmb_Mb + 0.1, 
    color = institution
  )
) + 
  stat_ecdf() + 
  geom_vline(xintercept = 10.1) + 
  theme_bw() + 
  labs(
    title = "Tumor mutation burden sample_distribution",
    x = "TMB (mutations per megabase)"
  ) +
  theme(
    plot.title.position = "plot",
    axis.title.y = element_blank(),
    axis.text.y = element_text(hjust = 0),
    strip.text = element_text(hjust = 0)
  ) + 
  scale_x_continuous(
    expand = expansion(mult = 0.01, add = 0),
    trans = 'log10'
  ) +
  scale_y_continuous(
    breaks = seq(0,1, by = 0.5),
    labels = paste0(seq(0,1, by = 0.5)*100, "%"),
    minor_breaks = seq(0,1, by = 0.25)
  ) + 
  guides(fill = "none") + 
  facet_wrap(
    vars(sample_type_simple_f), 
    ncol = 1,
    scales = "free" # free_x is the easiest way to get axes.
  ) +
  coord_cartesian(
    xlim = c(NA, max(dft_tmb$tmb_Mb + 0.2))
  ) + 
  scale_color_vibrant()
```

### R2.3.3 TMB eCDF by site

Another way we can view this is showing the cumulative distribution function for each site.  All MSK panels are tumor-normal and all others are tumor-only.  The black line is at TMB = 10.



```{r, include = T}
gg_tmb_ecdf_panel
```

It may also be helpful heuristically to state the proportion of samples over 10 mut/Mb by site:

```{r, include = T}
dft_tmb %>% 
  group_by(institution) %>%
  summarize(
    num_tmb_gte_10 = sum(tmb_Mb > 10, na.rm = T),
    pct_tmb_gte_10 = round(num_tmb_gte_10/n()*100, 1),
    .groups = 'drop'
  ) %>%
  flextable %>%
  autofit
```








```{r}
dft_tmb_lm <- dft_pt %>% 
  mutate(
    race_simple_f = case_when(
      naaccr_race_code_primary %in% "White" ~ "white",
      naaccr_race_code_primary %in% "Black" ~ "black",
      naaccr_race_code_primary %in% c("Chinese", "Other Asian") ~ "asian",
      T ~ "race_other_unk"
    )
  ) %>%
  select(
    record_id, race_simple_f
  ) 

dft_tmb_lm <- dft_tmb %>% 
  select(
    record_id,
    ca_seq,
    sample_type_simple_f,
    institution,
    panel_bp_exon,
    tmb_Mb,
    dob_cpt_report_yrs
  ) %>%
  left_join(
    dft_tmb_lm,
    .,
    by = c('record_id')
  )

dft_tmb_lm %<>%
  rename(
    pt_age_at_sample = dob_cpt_report_yrs
  ) %>%
  mutate(
    log10_panel_Mb_exon = log10(panel_bp_exon / 10^6),
    log10_tmb_Mb = log10(tmb_Mb + 0.1)
  ) %>%
  select(-panel_bp_exon, -tmb_Mb)

lm_tmb <- dft_tmb_lm %>%
  select(-record_id, -ca_seq) %>%
  fastDummies::dummy_cols(
    .data = .,
    remove_most_frequent_dummy = T,
    remove_selected_columns = T
  ) %>%
  glm(
    data = .,
    formula = log10_tmb_Mb ~ .,
    family = gaussian("identity")
  )

ft_lm_tmb <- lm_tmb %>%
  broom::tidy(.) %>%
  select(
    term, estimate, p.value
  ) %>%
  mutate(estimate = round(estimate, 4)) %>%
  filter(!(term %in% "(Intercept)")) %>%
  mutate(
    p.value = cfmisc::pval_nejm(p.value)
  )

ft_lm_tmb %<>%
  flextable(.) %>%
  autofit(.) %>%
  align(j = "p.value", align = "right")

# Lasso fit: not reported, just described.

# dft_tmb_lm_processed <- dft_tmb_lm %>%
#   select(-record_id, -ca_seq) %>%
#   fastDummies::dummy_cols(
#     .data = .,
#     remove_most_frequent_dummy = T,
#     remove_selected_columns = T
#   )

# glmnet::cv.glmnet(
#   x = (select(dft_tmb_lm_processed, -log10_tmb_Mb) %>%
#          as.matrix),
#   y = (select(dft_tmb_lm_processed, log10_tmb_Mb) %>%
#          as.matrix),
#   nfolds = 10,
#   family = gaussian('identity')
# ) %>%
#   coef.glmnet(., s = 'lambda.1se')

```

### R2.3.4 TMB associations

Above we see some evidence that MSK has a lower TMB on average than the other institutions, and tumor-normal sequencing is our hypothesized explanation.  Another possibility is confounding, which we consider briefly here by fitting a few models.

A number of clinical characteristics were shown to differ by site:  for example, compared with MSK, DFCI had more white participants, more early stage patients (who would yeild fewer metatstatic samples).  Below is the fit of a linear model for log10(TMB), using patient age, panel size (log10 of the combined exon size in the panel), indicators for race, indicators for sample type, indicators for institution.

```{r, include = T}
ft_lm_tmb
```

**Notes:**

- Even when adjusting for a handful of obvious potential confounders, MSK has a lower TMB than other sites (MSK is the reference).  This provides some indirect evidence that tumor-normal vs tumor-only sequencing is affecting TMB even after attempts to remove germline variants.
- A heavily penalized LASSO model gave qualitatively similar results:  the terms for institution, patient age at sample, and metastatic (relative to primary) were selected.
- This model is a pretty imperfect fit.  TMB is zero inflated and if we wanted to push this further or publish it we should think more about our model.



### R2.4.1 Oncogenic annotation impact

We discussed annotating and potentially filtering the data using the "oncogenic" feature from oncoKB (https://www.oncokb.org/).  Looking at the alteration level (multiple alterations per sample are possible), the following plot shows the impact this would have on the raw data.

```{r, include = T, fig.height = 4}
gg_onco_impact
```

Observations:

- If we filtered our data to include only likely oncogenic or oncogenic alterations, we lose most of the mutations, and a smaller proportion or the fusions and CNAs.




```{r}
gg_onco_impact_pathway <- dft_alt %>% 
  dplyr::count(pathway, oncogenic) %>%
  group_by(pathway) %>%
  mutate(
    prop = n / sum(n, na.rm = T),
    y_dummy = "a"
  ) %>%
  ungroup(.) %>%
  plot_alt_onco_impact(
    .,
    x_var = 'prop',
    x_lab = "Alteration (proportion)",
    y_var = "y_dummy",
    plot_subtitle = "Pathways: Gene lists from Sanchez-Vega (2018)"
  ) +
  facet_wrap(
    vars(pathway), 
    scales = "free",
    ncol = 3
  ) +
  theme(
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank()
  ) 
```



### R2.4.2a Onco. impact by pathways - proportions

The pathways here are very cursory - just using the gene lists from Sanchez-Vega (2018).  The goal of this analysis is just context for the OncoKB annotations - we would expect well known clinically important pathways like p53 to be more heavily annotated than genes that are not well categorized into a pathway.

```{r, include = T}
gg_onco_impact_pathway
```

**Observation:** Overall the pathways I was aware of (TP53, MYC, PI3K) were frequently annotated as oncogenic.  I was surprised that the alterations with no noted pathway were more frequently annotated as oncogenic than some in this list, like RTK_RAS and HIPPO.






```{r}
# Want to reorder the axis in a sensible way:
vec_alt_onco_count_fac_lev <- dft_alt %>%  
  filter(pathway != "None") %>%
  dplyr::count(pathway, oncogenic) %>%
  group_by(pathway) %>%
  summarize(
    oncogenic_n = sum(n[oncogenic %in% c("Likely Oncogenic", "Oncogenic")]),
    total_n = sum(n),
    new_factor_score = oncogenic_n - (total_n-oncogenic_n)
  ) %>%
  arrange(desc(new_factor_score)) %>%
  pull(pathway) %>%
  as.character(.)

gg_onco_impact_pathway_counts <- dft_alt %>% 
  filter(pathway != "None") %>%
  mutate(
    pathway = factor(
      pathway, levels = vec_alt_onco_count_fac_lev
    )
  ) %>%
  dplyr::count(pathway, oncogenic) %>%
  mutate(
    y_dummy = "a"
  ) %>%
  ungroup(.) %>%
  plot_alt_onco_impact(
    .,
    x_var = 'n',
    x_lab = "Alterations (count)",
    y_var = "pathway",
    plot_subtitle = "Pathways: Gene lists from Sanchez-Vega (2018)"
  ) +
  theme_bw() +
  theme(
    plot.title.position = "plot"
  )
```


### R2.4.2b Onco impact by pathways - counts

The following figure shows the same data as the previous as raw counts rather than proportions.

```{r, include = T}
gg_onco_impact_pathway_counts 
```







```{r}
# Want to reorder the axis in a sensible way:
vec_alt_onco_count_fac_lev_ddr <- dft_alt %>%  
  filter(pathway_ddr != "None") %>%
  dplyr::count(pathway_ddr, oncogenic) %>%
  group_by(pathway_ddr) %>%
  summarize(
    oncogenic_n = sum(n[oncogenic %in% c("Likely Oncogenic", "Oncogenic")]),
    total_n = sum(n),
    new_factor_score = oncogenic_n - (total_n-oncogenic_n)
  ) %>%
  arrange(desc(new_factor_score)) %>%
  pull(pathway_ddr) %>%
  as.character(.)

gg_onco_impact_pathway_ddr_counts <- dft_alt %>% 
  filter(pathway_ddr != "None") %>%
  mutate(
    pathway_ddr = factor(
      pathway_ddr, levels = vec_alt_onco_count_fac_lev_ddr
    )
  ) %>%
  dplyr::count(pathway_ddr, oncogenic) %>%
  mutate(
    y_dummy = "a"
  ) %>%
  ungroup(.) %>%
  plot_alt_onco_impact(
    .,
    x_var = 'n',
    x_lab = "Alterations (count)",
    y_var = "pathway_ddr",
    plot_subtitle = "Pathways: Gene lists from Pearl (2015)"
  ) +
  theme_bw() +
  theme(
    plot.title.position = "plot"
  )
```


### R2.4.2c Onco impact by DDR pathways - counts

DNA damage response genes are outlined in Pearl (2015) and there is an appendix to this document laying out some of the abbreviations and genes involved.  The goal of looking at this second set of pathways is thinking about mismatch repair (MMR) genes.

```{r, include = T}
gg_onco_impact_pathway_ddr_counts
```







```{r, eval = T}
# Note:  This section is incomplete - I didn't get to it, so this code is an irrelevant fragment if found long from now.
dft_levels_of_evidence <- dft_alt %>% 
  filter(
    oncogenic %in% c(
      "Likely Oncogenic",
      "Oncogenic"
    )
  ) %>%
  mutate(
    highest_level = if_else(
      is.na(highest_level),
      "None",
      highest_level
    )
  ) %>%
  tabyl(highest_level)


```


### R2.4.3 OncoKB levels of evidence

OncoKB levels of evidence deal with the strength of evidence that the gene predicts response to a drug.
- The highest level is 1, which is for "FDA-recognized biomarker predictive of response to an FDA-approved drug in this indication".  Example in prostate:  CDK12.
- The levels go down to 4, which represents compelling biological (but not clinical) evidence. Example in prostate:  PTEN.

I don't think this will be of great interest for a paper, but I would like the group to be aware of what information is in OncoKB and available for our use.  Here is a simple table of the level of evidence present for oncogenic alterations in our cohort:

```{r, include = T}
dft_levels_of_evidence %>%
  mutate(
    n_str = glue("{n} ({round(percent*100, 0)}%)")
  ) %>%
  select(highest_level, n_str) %>%
  flextable::flextable(.) %>%
  fontsize(size = 8, part = 'all') %>% 
  autofit(.)

```

**Note:** Most alterations do not have a level of evidence stated.  This includes some alterations in well known genes like TP53, SPOP, MYC.









```{r, eval = T}
# Note:  This section is incomplete - I didn't get to it, so this code is an irrelevant fragment if found long from now.
dft_mutation_effect <- dft_alt %>% 
  filter(
    oncogenic %in% c(
      "Likely Oncogenic",
      "Oncogenic"
    )
  ) %>%
  tabyl(mutation_effect)

# dft_mutation_effect %>% group_by(hugo) %>% mutate(nrow_gene = n()) %>% ungroup %>% filter(str_detect(mutation_effect, "^Loss|^Gain")) %>% filter(nrow_gene >= 2) %>% arrange(hugo)
```

### R2.4.4 OncoKB gain/loss of function

One more piece of information we have access to with oncogenic genes is whether the alteration is predicted to result in a gain or loss of function.  

The only potential use I can think of for this is if we want to use genes as a predictor, it might be advisable to model gain and loss of function genes separately.  For example, FOXA1 has some predicted gain and some predicted loss.  Here's a simple table of all oncogenic alterations:

```{r, include = T}
dft_mutation_effect %>%
  mutate(
    n_str = glue("{n} ({round(percent*100, 0)}%)")
  ) %>%
  select(mutation_effect, n_str) %>%
  flextable::flextable(.) %>%
  fontsize(size = 8, part = "all") %>% 
  flextable::autofit(.)
```







```{r}
dft_inst_freq <- dft_gt_any_alt %>%
  select(
    sample_id,
    hugo,
    tested,
    any_alt,
    any_alt_onco
  ) %>%
  left_join(
    .,
    select(
      dft_cpt, 
      sample_id = cpt_genie_sample_id,
      institution
    ),
    by = "sample_id",
    relationship = 'many-to-one'
  )

dft_inst_freq %<>%
  group_by(institution, hugo) %>%
  summarize(
    n_tested = sum(tested, na.rm = T),
    n_alt = sum(any_alt, na.rm = T),
    n_alt_onco = sum(any_alt_onco, na.rm = T),
    
    prop_alt = n_alt/n_tested,
    prop_alt_onco = n_alt_onco/n_tested,
    .groups = "drop"
  ) 

dft_inst_freq_all <- dft_inst_freq %>%
  group_by(hugo) %>%
  summarize(
    across(
      .cols = c(n_alt, n_alt_onco, n_tested),
      .fns = sum
    ),
    .groups = 'drop'
  ) %>%
  mutate(
    prop_alt = n_alt/n_tested,
    prop_alt_onco = n_alt_onco/n_tested
  ) %>%
  mutate(institution = "All")
    

# find the genes that are most freqently altered, limited
# to those with over ~600 tested.
vec_alt_most_common <- dft_inst_freq_all %>%
  filter(n_tested > 0.5*max(n_tested)) %>%
  arrange(desc(prop_alt)) %>%
  slice(1:20) %>%
  pull(hugo)

dfp_inst_freq <- bind_rows(
  dft_inst_freq_all,
  dft_inst_freq
) %>%
  filter(hugo %in% vec_alt_most_common) %>%
  mutate(
      institution = forcats::fct_inorder(institution),
      hugo = factor(hugo, levels = vec_alt_most_common)
  )



gg_inst_alt <- plot_alt_by_inst(
  dat = dfp_inst_freq,
  point_size = 2
)

gg_inst_alt_onco <- plot_alt_by_inst(
  dat = dfp_inst_freq,
  prop_var = "prop_alt_onco",
  plot_subtitle = "Only oncogenic alterations",
  point_size = 2
)

```
  
### R2.5.1a Alteration frequency by institution

The following plot show the percentage of tested samples with an alteration of any kind.  The black square shows the whole cohort number, and colored dots show the numbers at each institution.  

This plot is limited to genes tested in more than 50% of samples, and only the top 20 most frequently altered genes are shown.

```{r, include = T}
gg_inst_alt
```

**Observations:**

- Some genes are missing dots for institutions because the gene was never tested there.  An example is MGA at VICC and UHN - not included in any panel in this dataset.
- Most of the big outliers are at the small institutions.
- Even at DFCI and MSK, proportions of altered samples can be quite different depending on the gene.  An example that remains in the next plot is MYC, where DFCI has 2% of tested samples altered and MSK has 9%.

### R2.5.1b Alteration frequency by institution (oncogenic)

Same as the above plot, except we examine include only alterations which were annotated as Likely Oncogenic or Oncogenic by OncoKB.

```{r, include = T}
gg_inst_alt_onco
```






```{r}
dft_top_gene_bin <- dft_alt %>% 
  filter(hugo %in% vec_alt_most_common[1:20]) %>%
  group_by(sample_id, hugo) %>%
  summarize(exists = n() >= 1, .groups = "drop") %>%
  pivot_wider(
    names_from = hugo,
    values_from = exists
  ) 

# Add in rows where nothing at all was found:
dft_top_gene_bin <- dft_cpt %>%
  select(sample_id = cpt_genie_sample_id) %>%
  left_join(dft_top_gene_bin, by = "sample_id")
  
dft_top_gene_bin %<>%
  mutate(
    across(
      .cols = -sample_id,
      .fns = (function(x) {
        x <- as.integer(x)
        x <- if_else(is.na(x), 0L, x)
      })
    )
  ) %>%
  # just ordering:
  select(sample_id, vec_alt_most_common[1:20])


dft_gene_assoc <- test_fisher_co_occur(
  dat = dft_top_gene_bin,
  ignore_cols = c("sample_id"),
  top = 10,
  alpha = 0.05
)

dft_gene_assoc %<>%
  mutate(
    assoc_lab = glue("{ct_11} / {ct_10+ct_01}"),
    p_value_adj = p.adjust(p.value, method = "BH"),
    cont_table_lab = cont_table_lab_help(
      ct_11 = ct_11,
      ct_01 = ct_01,
      ct_10 = ct_10,
      ct_00 = ct_00
    )
  )

gg_gene_assoc <- plot_binary_association(
  dat = dft_gene_assoc,
  x_var = "var1_lab",
  y_var = "var2_lab",
  show_p_sig = T,
  label_var = "cont_table_lab",
  pval_var = "p_value_adj"
)  + 
  theme(
    axis.text.x.top = element_text(angle = -20, hjust = 1)
  )

```


### R2.6.1a Co-occurence, top 10 genes

The following plot shows the association between the 10 genes with the highest number of alterations.  Each gene is labelled with [brackets] showing the number of samples which were positive in the cohort.

The association (color) is determined by pairwise (one gene to one gene) Fisher's exact test over the samples.  Black dots represent significant results after correcting for multiple testing using the Benjamini-Hockberg (false discovery rate) method and significance threshold of 0.05.  The coloring is the same for any P value under an extreme threshold ($10^{-5}$) to avoid swamping the plot with results like TMPRSS2/ERG.

Each cell is labelled by four numbers.  This is the contingency table for the two genes represented in the cell.  For example, the top left number in the top left cell is the number of samples with an alteration in TP53 and APC.  The top right is the number with alteration in APC but not TP53, so and so on.

This methodology is similar to `maftools`.  The major difference here is we are considering alterations of any type (not just mutations), which seems important for this cohort.

```{r, include = T}
gg_gene_assoc
```

*Notes:*

- Sanity check:  Some of the significant results here have matches in the literature.  For example:
  - Negative associations for {SPOP, TMPRSS2} and {ATM, TP53}.
  - Positive associations for {TMPRSS2, TP53} 
- I'm would recommend we don't use the common "mutually exclusive" for events that only occur together infrequently.  Common but wrong!


```{r}
# Sensitivity analysis to the above:  Only people who had all these genes tested in their panels.
vec_genes_in_co_occur_plot <- (
      c(dft_gene_assoc$var1, 
        dft_gene_assoc$var2) %>% 
        unique
    )

vec_panels_with_all_top10 <- dft_gp_all %>%
  filter(
    hugo %in% vec_genes_in_co_occur_plot
  ) %>%
  select(cpt_seq_assay_id, hugo, tested) %>% 
  group_by(cpt_seq_assay_id) %>%
  summarize(
    has_all_top_10 = n() >= 10 # those with tested = F are implicitly missing currently.
  ) %>%
  filter(has_all_top_10) %>%
  pull(cpt_seq_assay_id) %>%
  as.character(.)

dft_alt_full_top_10_tested <- dft_alt %>%
  left_join(
    ., 
    select(dft_cpt, sample_id = cpt_genie_sample_id, cpt_seq_assay_id),
    by = 'sample_id'
  ) %>%
  filter(cpt_seq_assay_id %in% vec_panels_with_all_top10)

# Now we copy-paste the same code from above:
dft_top_gene_bin_sens <- dft_alt_full_top_10_tested %>% 
  filter(hugo %in% vec_genes_in_co_occur_plot) %>%
  group_by(sample_id, hugo) %>%
  summarize(exists = n() >= 1, .groups = "drop") %>%
  pivot_wider(
    names_from = hugo,
    values_from = exists
  ) 

# Add in rows where nothing at all was found:
dft_top_gene_bin_sens <- dft_cpt %>%
  filter(cpt_seq_assay_id %in% vec_panels_with_all_top10) %>%
  select(sample_id = cpt_genie_sample_id) %>%
  left_join(dft_top_gene_bin, by = "sample_id")
  
dft_top_gene_bin_sens %<>%
  mutate(
    across(
      .cols = -sample_id,
      .fns = (function(x) {
        x <- as.integer(x)
        x <- if_else(is.na(x), 0L, x)
      })
    )
  ) %>%
  # just ordering:
  select(sample_id, vec_genes_in_co_occur_plot)


dft_gene_assoc_sens <- test_fisher_co_occur(
  dat = dft_top_gene_bin_sens,
  ignore_cols = c("sample_id"),
  top = 10,
  alpha = 0.05
)

dft_gene_assoc_sens %<>%
  mutate(
    assoc_lab = glue("{ct_11} / {ct_10+ct_01}"),
    p_value_adj = p.adjust(p.value, method = "BH"),
    cont_table_lab = cont_table_lab_help(
      ct_11 = ct_11,
      ct_01 = ct_01,
      ct_10 = ct_10,
      ct_00 = ct_00
    )
  )

gg_gene_assoc_sens <- plot_binary_association(
  dat = dft_gene_assoc_sens,
  x_var = "var1_lab",
  y_var = "var2_lab",
  show_p_sig = T,
  label_var = "cont_table_lab",
  pval_var = "p_value_adj"
)  + 
  theme(
    axis.text.x.top = element_text(angle = -20, hjust = 1)
  )


```


### R2.6.1b Co-occurence, top 10 genes, sensitivity

As a sensitivity analysis, we discussed repeating the previous plot on only subjects who had panels where those top 10 genes were tested.  The following plot shows this:

```{r, include = T}
gg_gene_assoc_sens
```

Notes:

- The results are notably different from the previous plot.  
- There's a circular element to our sensitivity logic here.  To be included in the first co-occurence plot, a gene must have been in many panels because we only included genes with a large number of total alterations (top 10 by count).  This excludes genes not universally tested but with high alteration frequencies (example: KMT2C, which we know has a high alteration frequency from R2.4.1, but is tested in only about 700 of 1200 samples).
  - Might be better to limit to genes with high alteration frequency (e.g. 5%) and a generous threshold for the number tested, as in R2.4.1, rather than taking the top 10 by bulk count of altered samples.

```{r}


dft_pathway_bin <- create_pathway_binary(
  dat_cpt = dft_cpt,
  dat_alt = dft_alt,
  path_col = "pathway"
)

dft_pathway_assoc <- test_fisher_co_occur(
  dat = dft_pathway_bin,
  ignore_cols = c("sample_id", "None"),
  top = 10, # no limit.
  alpha = 0.05
)

dft_pathway_assoc %<>%
  mutate(
    cont_table_lab = cont_table_lab_help(
      ct_11 = ct_11,
      ct_01 = ct_01,
      ct_10 = ct_10,
      ct_00 = ct_00
    ),
    p_value_adj = p.adjust(p.value, method = "BH")
  )

gg_pathway_assoc <- plot_binary_association(
  dat = dft_pathway_assoc,
  x_var = "var1_lab",
  y_var = "var2_lab",
  show_p_sig = T,
  label_var = "cont_table_lab",
  pval_var = "p_value_adj"
)  + 
  theme(
    axis.text.x.top = element_text(angle = -20, hjust = 1)
  )

gg_pathway_assoc



```

### R2.6.2a Co-occurence, pathway

See previous item for methods description.  This uses the pathways of the Sanchez-Vega (2018) paper.

```{r, include = T}
gg_pathway_assoc
```

**Notes:**

- With one exception the pathways are positively associated, so a sample with an alteration in pathway X is more likely to have an alteration in pathway Y.  
- This could be related to samples with very high rates of alteration/mutation.

```{r}

dft_cpt_no_hyper_mut <- dft_cpt %>% 
  filter(tmb_Mb < 10)

dft_pathway_bin_no_hyper_mut <- create_pathway_binary(
  dat_cpt = dft_cpt_no_hyper_mut,
  dat_alt = dft_alt,
  path_col = "pathway"
)

dft_pathway_assoc_no_hyper_mut <- test_fisher_co_occur(
  dat = dft_pathway_bin_no_hyper_mut,
  ignore_cols = c("sample_id", "None"),
  top = 10, # no limit.
  alpha = 0.05
)

dft_pathway_assoc_no_hyper_mut %<>%
  mutate(
    cont_table_lab = cont_table_lab_help(
      ct_11 = ct_11,
      ct_01 = ct_01,
      ct_10 = ct_10,
      ct_00 = ct_00
    ),
    p_value_adj = p.adjust(p.value, method = "BH")
  )

gg_pathway_assoc_no_hyper_mut <- plot_binary_association(
  dat = dft_pathway_assoc_no_hyper_mut,
  x_var = "var1_lab",
  y_var = "var2_lab",
  show_p_sig = T,
  label_var = "cont_table_lab",
  pval_var = "p_value_adj"
)  + 
  theme(
    axis.text.x.top = element_text(angle = -20, hjust = 1)
  )

gg_pathway_assoc_no_hyper_mut


```



### R2.6.2b Co-occurence, pathway, hypermutated removed

A variant of the previous plot with hypermutated samples removed.  Hypermutated is defined as a TMB of greater than 10 mutations per megabase.

```{r, include = T}
gg_pathway_assoc_no_hyper_mut
```

Notes:

- We hypothesized that the completed dominance of positive pathway associations in the previous plot might be due to hypermutated samples.  
- As expected, with the hypermutated samples removed we see far fewer significant results and some negative association estimates.





```{r, eval = F}
# This code chunk works I just think it's pointless.
dft_pathway_ddr_bin <- dft_alt %>% 
  group_by(sample_id, pathway_ddr) %>%
  summarize(exists = n() >= 1, .groups = "drop") %>%
  pivot_wider(
    names_from = pathway_ddr,
    values_from = exists
  ) 

vec_pathway_ddr_lev <- dft_alt %>%
  filter(!(pathway_ddr %in% "None")) %>%
  arrange(pathway_ddr) %>%
  pull(pathway_ddr) %>% unique %>% as.character

# Add in rows where nothing at all was found:
dft_pathway_ddr_bin <- dft_cpt %>%
  select(sample_id = cpt_genie_sample_id) %>%
  left_join(dft_pathway_ddr_bin, by = "sample_id")
  
dft_pathway_ddr_bin %<>%
  mutate(
    across(
      .cols = -sample_id,
      .fns = (function(x) {
        x <- as.integer(x)
        x <- if_else(is.na(x), 0L, x)
      })
    )
  ) %>%
  # just ordering:
  select(sample_id, vec_pathway_ddr_lev)

dft_pathway_ddr_assoc <- test_fisher_co_occur(
  dat = dft_pathway_ddr_bin,
  ignore_cols = c("sample_id"),
  top = 10, # no limit.
  alpha = 0.05
)

dft_pathway_ddr_assoc %<>%
  mutate(
    cont_table_lab = cont_table_lab_help(
      ct_11 = ct_11,
      ct_01 = ct_01,
      ct_10 = ct_10,
      ct_00 = ct_00
    ),
    p_value_adj = p.adjust(p.value, method = "BH")
  )



gg_pathway_ddr_assoc <- plot_binary_association(
  dat = dft_pathway_ddr_assoc,
  x_var = "var1_lab",
  y_var = "var2_lab",
  show_p_sig = T,
  label_var = "cont_table_lab",
  pval_var = "p_value_adj"
)  + 
  theme(
    axis.text.x.top = element_text(angle = -20, hjust = 1)
  )

gg_pathway_ddr_assoc
```







## Upcoming

- Lookup table for alterations.
- Further requests


## Details/Appendices

### Structural variants

**Question:** At one of our early meetings, someone asked about structural variants and whether they would be covered by our assessments. 

**Answer:** Yes, with some limits.  In main GENIE v12, which forms the foundation for this BPC cohort, fusion files were still in use and had not been replaced by SV files.  We will use this file for analysis, and while we know the class of structural variants is broader than fusions, my understanding is that in practice these pipelines/files cover similar ground.

There is also the question of whether a particular panel covers structural variants - some do and some do not in this dataset.  The vast majority of our samples are tested with panels that can assess structural variants (for example, all the MSK IMPACT and DFCI ONCOPANELs look at SVs).  Some of the smaller panels (UHN_48-V1) do not cover SVs.  

A similar issue is present for CNAs - some panels cover them and some don't.  Additionally, reading the data guide, some only cover gene level CNAs and not intragenic CNAs. 

### UHN ERG/TMPRSS2 fusions

**Question** In the plot of alteration frequency by institution UHN stands out with zero ERG and TMPRSS2 alterations.  The question is why.

**Answer** The answer is that only one UHN panel in this dataset (UHN-OCA-V3) has the ability to detect fusions.  Furthermore, only 2 samples were tested with this panel.  So we shouldn't be surprised that fusion phenomena don't appear in the data for UHN, and we have a clean explanation for the plot.

In our meeting on October 12 I incorrectly stated that I thought about half the samples were tested using panels that have the ability to detect fusions - hence the need for this claification.

### DNA damage repair pathway details

Thanks to Konrad Stopsack for providing the code to generate groups from Pearl (2015).  The following abbreviations are used:

- BER - Base excision repair.
- Checkpoint - Checkpoint factors/signalling.
- FA - Fanconi anemia pathway.
- HR - Homologous recombination.
- MMR - Mismatch repair, "MMR corrects replication errors that cause the incorporation of the wrong nucleotide (a mismatch) and nucleotide insertions and deletions"
- NER - Nucleotide excision repair.
- NHEJ - Non-homologous end joining.
- Other - Genes associated with DDR which did not fit into another category.
- Other DSR genes - Other double strand repair genes.
- Other SSR genes - Other single strand repair genes.
- Probable - Having a probable role in the DNA damage response process.
- TLS - Trans lesion synthesis.

For any further detail please ask or consult the paper.

For genes that fit into more than one pathway the following prioritization was used to create mutually exclusive groups:  "MMR" > "HR" > "FA" > "NHEJ" > "BER" > "NER".  That is, if a gene belongs to the MMR, HR and NHEJ pathways, it is coded as part of the MMR pathway for our analysis.

The following table lists the genes involved in these pathways which actually have alterations in our dataset:

```{r, include = T}
dft_alt %>%
  filter(!(pathway_ddr %in% "None")) %>%
  count(pathway_ddr, hugo) %>%
  mutate(pathway_ddr = as.character(pathway_ddr)) %>%
  arrange(pathway_ddr, hugo) %>%
  group_by(pathway_ddr) %>%
  summarize(
    genes = paste(hugo, collapse = ", ")
  ) %>%
  flextable(.) %>%
  fontsize(size = 8, part = "all") %>% 
  autofit(.)
```







