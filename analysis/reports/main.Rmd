---
title: "GENIE BPC Prostate Cancer - Landscape Report"
author: "Alex Paynter"
date: "Started April 4, 2023"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, include = F,
                      warning = F, message = F,
                      fig.width = 7, fig.height = 5)
k_dpi <- 150
```


<style type="text/css">
.main-container {
  max-width: 1000px !important;
  margin: auto;
}
</style>



```{r}
library(cli)
library(readr)
library(here)
library(dplyr)
library(tidyr)
library(purrr)
library(rlang)
library(magrittr)
library(janitor)
library(stringr)
library(vctrs)
library(glue)

library(ggplot2)
library(ggrepel)

library(gt)
library(gtsummary)
library(sunburstR)
library(huxtable)


as_list(here("R", dir(here("R"))))

# Source everything in the "R" folder - just functions, no scripts.
purrr::walk(.x = here("R", dir(here("R"))), .f = source)
```


```{r, set_gtsummary_theme}
theme_gtsummary_compact()
```


```{r, warning = T}
read_wrap <- function(p) {
  read_csv(file = here("data-raw", p), show_col_types = F)
}

dft_pt <- read_wrap("patient_level_dataset.csv")
dft_ca_ind <- read_wrap("cancer_level_dataset_index.csv")
dft_img <- read_wrap("imaging_level_dataset.csv")
dft_med_onc <- read_wrap("med_onc_note_level_dataset.csv")
dft_path <- read_wrap("pathology_report_level_dataset.csv")
dft_regimens <- read_wrap("regimen_cancer_level_dataset.csv")
dft_tm <- read_wrap("tm_level_dataset.csv")
dft_cpt <- read_wrap("cancer_panel_test_level_dataset.csv")

# A few sanity checks on the data:
if ((dft_pt$record_id %>% duplicated %>% any)) {
  stop("Duplicated records in patient level dataset.")
}

if (any(dft_pt$naaccr_sex_code != "Male")) {
  warning("Non-male sex detected for at least one participant (unexpectedly for Prostate cancer)")
}

```


```{r, demo_data_manipulation, include = F}
dft_pt_baseline_sub <- dft_pt %>%
  mutate(
    `Race (primary)` = format_ptlevel_naaccr_race_code_primary(
      naaccr_race_code_primary
    ),
    `Ethnicity` = format_ptlevel_naaccr_ethnicity_code(
      naaccr_ethnicity_code
    )) %>%
  select(record_id, 
         Institution = institution,
         `Race (primary)`,
         `Ethnicity`)


dft_ca_ind_baseline_sub <- dft_ca_ind %>%
  mutate(
    ca_dx_how = format_ca_dx_how(ca_dx_how),
    ca_hist_adeno_squamous = format_ca_hist_adeno_squamous(ca_hist_adeno_squamous),
    stage_dx = format_stage_dx(stage_dx),
    ca_path_n_stage = format_ca_path_n_stage(ca_path_n_stage)
  ) %>%
  select(
    record_id,
    `Age at dx (years)` = dob_ca_dx_yrs,
    `Stage at dx` = stage_dx,
    `Source of dx` = ca_dx_how,
    # Update May 5:  Removed histology (unimportant)
    # `Histology` = ca_hist_adeno_squamous, # at dx?
    `Pathologic N Stage` = ca_path_n_stage # describes spread to lymph nodes
  ) 

# On histology alternatives:
# - naaccr_histology_cd has mostly the same info according to https://seer.cancer.gov/icd-o-3/.  Most of these levels are singletons.



dft_tm_baseline <- dft_tm %>%
  psa_test_unit_convert() %>%
  filter(!is.na(tm_num_result_conv)) %>%
  # filter down to results at or on diagnosis.
  # Importantly there are psa/test values available before diagnosis for
  #   many participants.
  filter(dx_tm_days <= 30 & dx_tm_days >= -180) %>% 
  group_by(record_id, tm_type) %>%
  # Prioritize values at/before 
  mutate(abs_dx_tm_days = abs(dx_tm_days)) %>%
  arrange(abs_dx_tm_days) %>%
  slice(1) %>%
  ungroup() %>% 
  select(record_id, 
         tm_type, 
         tm_num_result_conv, 
         tm_result_units_conv) 

# Visual check:
# ggplot(dft_tm_baseline, aes(x = dx_tm_days)) + stat_ecdf()


# kind of a hacky check:  the resulting tibble will be 2 rows and 3 columns if there are 2 analytes with one unit each.
tm_unit_conv_check <- dft_tm_baseline %>% 
  tabyl(tm_type, tm_result_units_conv) %>% 
  dim
if (!all.equal(tm_unit_conv_check,c(2,3))) {
  cli::abort("Unit conversion problem.")
}

dft_tm_baseline %<>% 
  select(-tm_result_units_conv) %>%
  tidyr::pivot_wider(
    names_from = "tm_type",
    values_from = "tm_num_result_conv"
  ) %>%
  rename(
    `PSA (ng/mL)` = PSA,
    `Testosterone (ng/dL)` = Testosterone
  )










dft_demo <- full_join(
  dft_pt_baseline_sub,
  dft_ca_ind_baseline_sub,
  by = "record_id"
) %>%
  full_join(
    .,
    dft_tm_baseline,
    by = "record_id"
  )

```

## Content

### R1.1a: Characteristics at dx

For most analyses, especially survival, the timing of observations is critical.  Here we have separated baseline characteristics (Table R1.1) and characteristics which could represent a first post-baseline observation (Table R1.2).  After speaking with Jennifer Hoppe at AACR, my understanding is that for all prostate specific variables in the cancer diagnosis dataset, curators were instructed to curate from time of diagnosis through completion of surgeries in the first course of treatment.  Therefore, those variables are in Table R1.2 unless we can confirm they were exclusively measured at baseline.

For Testosterone and PSA, an arbitrary choice was made to limit observations to those from 180 days before to 30 days after diagnosis of prostate cancer.  Notably this leaves the majority of the cohort unobserved at baseline on these variables.  See appendix for unit conversion assumptions.


```{r, tab_r1_1a, include = T}
dft_demo %>%
  select(-record_id) %>%
  gtsummary::tbl_summary(data = .)
```

### R1.1b: Characteristics at dx by site

Observations:

- MSK, UHN and VICC have more late stage cancers (about 50%).  DFCI has more Stage II/III cancers.
- Several variables are 100% unknown at UHN:  Histology and Ethnicity.

```{r, tab_r1_1b, include = T}
dft_demo %>%
  select(-record_id) %>%
  gtsummary::tbl_summary(data = ., by = Institution)
```









```{r}
dft_ca_ind_post_baseline <- dft_ca_ind %>%
  mutate(
    ce_num = format_cores(ca_pros_num_cores),
    cp_num = format_cores(ca_pros_num_corespos),
    clin_gleason = format_gleason(ca_pros_clin_gscore)
  ) %>%
  select(record_id, ce_num, cp_num, clin_gleason)



dft_med_onc_post_baseline <- dft_med_onc %>%
  group_by(record_id) %>%
  arrange(md_visit_number) %>%
  # filter down to the first determination made.
  #  That is, we will ignore rows with "Not stated in the Impression/Plan", unless that is the only type of entry ever
  #  Made for the patient.
  filter(str_detect(md_pca_status, "(CRPC)|(HSPC)") | 1:n() == n()) %>%
  slice(1) %>%
  ungroup %>%
  # First castration-resistance determination:
  mutate(first_cast_det = if_else(str_detect(md_pca_status, "Not stated in"),
                              "Never stated in Impression/Plan",
                              md_pca_status),
         first_cast_det = factor(first_cast_det)) %>%
  select(record_id,
         first_cast_det)

# Dominant units for PSA are ng/mL
# Dominant units for Testosterone are ng/dL

tm_missing_units <- dft_tm %>%
  filter(tm_type %in% c("PSA", "Testosterone")) %>%
  group_by(tm_type) %>%
  filter(is.na(tm_result_units) & !is.na(tm_num_result)) %>%
  summarize(n = n())

# # Visual check on the unit conversions if desired.  Just looking for
# good overall overlap between converted and non-converted units.
# dft_tm %>%
#   psa_test_unit_convert() %>%
#   mutate(converted_unit = tm_result_units != tm_result_units_conv) %>%
#   ggplot(., aes(x = 1, y = tm_num_result_conv, color = converted_unit)) + 
#   geom_jitter(width = 1, height = 0) + 
#   scale_y_log10() + 
#   facet_wrap(vars(tm_type))



# dft_ca_ind_post_baseline %>% count(record_id) %>% arrange(desc(n))
# dft_med_onc_post_baseline %>% count(record_id) %>% arrange(desc(n))
# dft_ca_ind_post_baseline %>% count(record_id) %>% arrange(desc(n))


dft_post_baseline <- full_join(
  dft_ca_ind_post_baseline,
  dft_med_onc_post_baseline,
  by = "record_id"
) 

dft_post_baseline %<>%
  left_join(
    ., 
    select(dft_pt, record_id, institution),
    by = "record_id"
  )

dfp_post_baseline <- dft_post_baseline %>%
  select(
    record_id,
    Institution = institution,
    # Update: May 5 - remove, not needed.
    # `Prostate cores examined` = ce_num,
    # `Prostate cores positive` = cp_num,
    `Clinical Gleason score` = clin_gleason,
    `Castration status (first)` = first_cast_det,
  )
  

```


### R1.2a: Characteristics (dx onward)

The characteristics in this table were known to be curated from diagnosis to the end of surgeries in the first round of treatment.  In the case of castration status, we take the first value where CRPC/HRPC was declared (that is, ignore the records where no determination was made).


```{r, tab_r1_2a, include = T}
dfp_post_baseline %>%
  select(-c(record_id, Institution)) %>%
  gtsummary::tbl_summary(data = .)
```

### R1.2b: Characteristics (dx onward) by site

Observations on the table:

- DFCI has more participants with low first observed Gleason scores.  This is consistent with the early stage observation from the previous table.
- MSK has more participants with HSPC on the first observation, which seems inconsistent with higher average stage.  This may indicate a scoring difference on HSPC/CRPC between institutions.

```{r, tab_r1_2b, include = T}
dfp_post_baseline %>%
  select(-record_id) %>%
  gtsummary::tbl_summary(data = ., by = Institution)
```







```{r}
# Just checking an assumption I have about the data:
if (nrow(
  (dft_med_onc %>% filter(!(record_id %in% dft_ca_ind$record_id)))
) != 0) {
  cli::cli_abort("Med onc data contains partipants not in the index cancer dataset.")
}

dft_count_all <- make_obs_count_df(
  med_onc_dat = dft_med_onc,
  img_dat = dft_img,
  reg_dat = dft_regimens,
  ca_ind_dat = dft_ca_ind
)

obs_type_levs <- c("Med Onc Notes",
                   "Regimens",
                   "Total Scans",
                   "CT Scan",
                   "MRI Scan",
                   "PET or PET-CT")
                   
dft_count_long <- dft_count_all %>%
  select(record_id, 
         n_med_onc, 
         n_scan_ct, 
         n_scan_mri, 
         n_scan_pet_or_pet_ct,
         n_scan_total,
         n_regimens) %>%
  pivot_longer(cols = -record_id,
               names_to = "type",
               values_to = "n") %>%
  mutate(
    type_f = case_when(
      type %in% "n_med_onc" ~ obs_type_levs[1],
      type %in% "n_regimens" ~ obs_type_levs[2],
      type %in% "n_scan_total" ~ obs_type_levs[3],
      type %in% "n_scan_ct" ~ obs_type_levs[4],
      type %in% "n_scan_mri" ~ obs_type_levs[5],
      type %in% "n_scan_pet_or_pet_ct" ~ obs_type_levs[6]
    ),
    type_f = factor(type_f, levels = obs_type_levs)
  )

dft_count_quantiles <- dft_count_long %>%
  nest(.by = type_f) %>%
  mutate(res = purrr::map(.f = get_quantile_df,
                          .x = data,
                          var = "n")
  ) %>%
  select(type_f, res) %>%
  unnest(res) 


gg_count_ecdf <- ggplot(data = dft_count_long,
         aes(x = n)) + 
  stat_ecdf(color = '#4477AA') + 
  geom_text_repel(data = dft_count_quantiles,
             # yes, this is screwed up:
             aes(x = y, y = n, label = y),
             hjust = 0, nudge_x = 8, size = 2.5,
             direction = "x",
             segment.size = 0.15
            ) + 
  theme_bw() +
  facet_wrap(vars(type_f), scales = "free", nrow = 2) + 
  scale_y_continuous(
    name = "Cohort fraction",
    breaks = c(0, .5, 1),
    labels = paste0(c(0, .5, 1)*100, "%")
  ) + 
  theme(
    strip.text = element_text(hjust =0)
  )


  
```


### R1.3a Observation counts (eCDF figure)

The follow plot shows the empirical cumulative distirbution function for the number of observations per subject.  In each plot, three numbers are labelled:  the 25th percentile, the median and the 75th percentile.  

In addition to the basic stats this gives our intended audience for this plot (future BPC data users) information they may need to know in fitting their models.  For example, you can tell how many people have at least 3 regimens, or roughly how many people have over 75 medical oncology notes.

```{r, output_obs_ecdf, include = T}
gg_count_ecdf
```





```{r, create_obs_table, include = T}
dfp_obs_count <- dft_count_all %>%
  select(
    Regimens = n_regimens,
    `MedOnc Notes` = n_med_onc,
    `CT` = n_scan_ct,
    `MRI` = n_scan_mri,
    `Bone Scans` = n_scan_bone,
    `PET or PET-CT` = n_scan_pet_or_pet_ct,
    `Total scans` = n_scan_total
  ) %>% 
  gtsummary::tbl_summary(data = .) %>%
  modify_header(
    label = '**Observation Type**'
  )
  
```


### R1.3b Observation counts (table)

This is a simpler presentation of the same three statistics as the previous figure:

```{r, include = T}
dfp_obs_count 
```







```{r}
# Sunburst plots are created in a distinct script,
#   save_sunbursts.R.
js_full_sun <- readRDS(
  here("data", "sunburst_plots","full.rds")
)
```

### R1.4a Regimens sunburst, full cohort

This is a sunburst plot, which shows the regimen sequences used by participants in the cohort.  The innermost ring shows the first line therapy, the second ring shows second line therapy, and so on.  For tractability I capped the number of regimens at 3, but we can extend further if needed.

This is an **interactive plot**, so you can mouse over each sector to reveal the drugs represented.

*Credit:* MSK stats team for pioneering the use of these plots for drug regimens - I like them!

```{r, include = T}
js_full_sun
```



```{r}
js_crpc_sun <- readRDS(
  here("data", "sunburst_plots","crpc.rds")
)
```

### R1.4b Regimens sunburst, post-CRPC

Same plot as previous, limited to regimens started on or after participants were declared Castrate-resistant by medical oncologist note.

**Observation:** Shockingly similar.

```{r, include = T}
js_crpc_sun
```





```{r}
dft_drug <- dft_ca_ind %>%
  select(record_id, ca_seq) %>%
  left_join(
    ., 
    dft_regimens,
    by = c("record_id", "ca_seq")
  ) %>% 
  select(record_id:redcap_ca_index,
         drugs_drug_1:dx_drug_end_or_lastadm_int_5) %>%
  mutate(across(
    c(contains("drugs_drug_")),
    .fn = ~ vec_cast(.x, to = "character"))
  ) %>%
  mutate(
    across(
      .cols = drugs_startdt_int_1:dx_drug_end_or_lastadm_int_5,
      .fns = as_double
    )
  )



# split off the character values, we'll do those separately
#   to avoid casting issues.
dft_drug_char <- dft_drug %>%
  select(record_id, 
         regimen_number, 
         ca_seq,
         drugs_drug_1: drugs_drug_5)

dft_drug %<>%
  select(-contains("drugs_drug_")) %>%
  pivot_longer(
    cols = drugs_startdt_int_1:dx_drug_end_or_lastadm_int_5,
    names_to = "var",
    values_to = "value"
  ) %>%
  # Because "drug_num" is confusing when we have "drugs_num" in 
  #   the raw data.
  # This is only an id for drug within regimen within person.
  mutate(drug_id = readr::parse_number(var),
         var = stringr::str_replace(var, "_[0-5]", "")) %>%
  pivot_wider(names_from = "var", values_from = "value") %>%
  select(record_id, 
         contains("regimen_number"), 
         drug_id, 
         everything()) 


# Now do it again for the cluster of character columns.
#   All the previous ones were integer/double.
dft_drug_char %<>%
  pivot_longer(
    cols = drugs_drug_1: drugs_drug_5,
    names_to = "var",
    values_to = "value"
  ) %>%
  # Because "drug_num" is confusing when we have "drugs_num" in 
  #   the raw data.
  # This is only an id for drug within regimen within person.
  mutate(drug_id = readr::parse_number(var),
         var = stringr::str_replace(var, "_[0-5]", "")) %>%
  # because there is only one column we don't need to pivot here,
  #  just rename.
  select(record_id, regimen_number, drug_id, drug = value)

dft_drug <-
  left_join(dft_drug, dft_drug_char, 
            by = c("record_id", "regimen_number", "drug_id")) %>%
  relocate(drug, .before = drugs_startdt_int)

# empty rows here have no meaning - it's just regimens with less
#   than 5 drugs which is not suprising or interesting.
dft_drug %<>%
  filter(!is.na(drug))


dfp_top_drugs <- dft_drug %>%
  group_by(record_id, drug) %>%
  summarize(observed = 1, .groups = "drop") %>%
  group_by(drug) %>%
  summarize(n = sum(observed)) %>%
  arrange(desc(n)) %>%
  head(10)

dc_wrap <- function(drug_name) {
  get_drug_compliments(dft_drug, drug_name) %>%
    reshape_drug_compliments()
}

dfp_top_drugs <- dfp_top_drugs %>%
  mutate(df_top_comp = purrr::pmap(
    .l = list(drug_name = drug),
    .f = dc_wrap
  )) %>%
  tidyr::unnest(df_top_comp) %>%
  mutate(drug = str_replace(drug, "\\(.*\\)", ""))
```


### R1.4c Drugs used, table

The number of participants (n) who used a particular drug in any regimen.  `Compliment 1` states the drug mostly commonly used in regimens containing `Drug`.  

*Example interpretation of a row*  Bicalutamide was used by 627 participants over the course of followup.  Regimens containing bicalutamide also frequently contained Docetaxel (4.1% of regimens with bicalutamide had docetaxel) and Degarelix.

```{r, print_drug_table, include = T}
dfp_top_drugs %>% 
  select(Drug = drug, 
         n = n, 
         `Compliment 1` = first, 
         `Compliment 2` = second) %>%
  huxtable::hux(.) %>%
  huxtable::theme_striped(.)
```









```{r, create_top_drug_plot}
n_prca_cohort <- dft_ca_ind %>% nrow()

set.seed(3890)
gg_top_drugs <- dfp_top_drugs %>%
  select(drug, n) %>%
  mutate(
    prop = n/n_prca_cohort,
    str = glue("n={n} ({formatC(prop*100, digits = 1, format = 'f')}%)")
  ) %>%
  mutate(drug = forcats::fct_inorder(drug)) %>%
  ggplot(data = .,
         aes(x = prop, y = drug, fill = drug)) +
  geom_col() + 
  annotate(
    geom = 'rect', 
    xmin = 1, xmax = 1.5, ymin = -2, ymax = 15,
    color = "gray80", fill = "gray80"
  ) + 
  geom_text(size = 2.5, 
            nudge_x = .05, 
            hjust = 0, 
            aes(label = str)) + 
  scale_fill_manual(
    values = sample(make_sun_pal(10))
  ) + 
  scale_x_continuous(
    name = "Proportion of cohort",
    breaks = c(0,0.5,1),
    labels = paste(c(0, 50, 100), "%"),
    expand = expansion(mult = c(0,0.05), add = c(0,0))
  ) + 
  scale_y_discrete(limits = rev) + 
  coord_cartesian(xlim = c(0,1.1), ylim = c(0.9, 10.1)) + 
  theme_bw() +
  theme(
    axis.title.y = element_blank(),
    legend.position = "none"
  )
```

### R1.4d Drugs used, figure

Proportion of the cohort ever exposed to each agent, limited to the top 10 most used.

```{r, output_top_drug_plot, include = T, fig.height = 3, fig.width = 7}
gg_top_drugs
```





```{r}
set.seed(189)
random_pt_subset <- dft_pt$record_id %>% 
  unique %>% 
  sample(x = ., size = 40, replace = F)

dft_cast_block <- make_cast_status_block(
  dft_med_onc, 
  dft_ca_ind, 
  remove_hspc_after_crpc = T)

dft_event <- make_event_df(
  ca_ind_dat = dft_ca_ind,
  cast_block_dat = dft_cast_block
)

gg_swim_cast_dx <- plot_swim_block_status(
  #line_pal = c("gray80", "#ddaa33", "#bb5566"),
  block_dat = dft_cast_block,
  block_var = "md_cast_status_f",
  event_dat = dft_event,
  event_var = "event",
  pt_subset = random_pt_subset
)

ggsave(filename = here("fig", "R1.5a_swim_cast_dx.png"),
       plot = gg_swim_cast_dx,
       width = 7, height = 5, dpi = k_dpi)
```

### R1.5a: Swimmer plot, CRPC/HSPC, from dx

**General note for swimmer plots** For the moment we're using a random subset of participants.  When we decide on a final set of plots for the manuscript, it may make sense to choose a representative cohort based on what we're showing.

We have removed indications of hormone-sensitive prostate cancer in the data which occur after designations of castrate-resistant prostate cancer.  This is based on personal communications with our clinical collaborators, who shared that once someone is considered castrate-sensitive they retain that status for life.

```{r, include = T}
gg_swim_cast_dx
```











```{r}
dft_cast_block_by_age <- left_join(
  dft_cast_block,
  (dft_ca_ind %>% select(record_id, age_dx)),
  by = "record_id"
) %>%
  mutate(
    across(
      .cols = c(dx_block_start, dx_block_end, tt_os_dx_yrs),
      .fn = (function(x) x + age_dx)
    )
  ) 

dft_event_by_age <- left_join(
  dft_event,
  (dft_ca_ind %>% select(record_id, age_dx)),
  by = "record_id"
) %>%
  mutate(t_yrs = t_yrs + age_dx)

gg_swim_cast_age <- plot_swim_block_status(
  block_dat = dft_cast_block_by_age,
  block_var = "md_cast_status_f",
  event_dat = dft_event_by_age,
  event_var = "event",
  pt_subset = random_pt_subset
)

gg_swim_cast_age <- gg_swim_cast_age + 
  scale_x_continuous(name = "Age (years)")

ggsave(filename = here("fig", "R1.5b_swim_cast_age.png"),
       plot = gg_swim_cast_age,
       width = 7, height = 5, dpi = k_dpi)

```

### R1.5b: Swimmer plot, CRPC/HSPC, by Age

```{r, include = T}
gg_swim_cast_age 
```









```{r}
dft_dmet_block <- make_dmet_status_block(ca_ind_dat = dft_ca_ind)

gg_swim_dmet_dx <- plot_swim_block_status(
  #line_pal = c("gray80", "#ddaa33", "#bb5566"),
  block_dat = dft_dmet_block,
  block_var = "dmet_status",
  event_dat = dft_event,
  event_var = "event",
  pt_subset = random_pt_subset,
  line_pal = c("#6699cc", "#ee99aa")
)

ggsave(filename = here("fig", "R1.5c_swim_dmet_dx.png"),
       plot = gg_swim_dmet_dx,
       width = 7, height = 5, dpi = k_dpi)
```

### R1.5c: Swimmer plot, Distant metastasis status, from dx

```{r, print_swim_dmet_dx, include = T}
gg_swim_dmet_dx
```





## Appendices

### Testosterone/PSA unit conversions

Testosterone and PSA were recorded under a number of units.  We assumed the following conversion factors:

**PSA** 

- 1 ng/dL is equal to 0.01 ng/mL.
- 1 μg/dL is equal to 1 ng/mL.
- PSA levels in nmol/L (2 results) were discarded as it seemed exceptionally rare to state PSA this way (but common for testosterone, so an easy mistake to make).
- Any PSA results with missing units were discarded (n = `r pull(filter(tm_missing_units, tm_type %in% "PSA"), n)`)

**Testosterone** 

- 1 ng/mL is equal to 100 ng/dL.
- 1 nmol/L is equal to 28.81 ng/dL.
- 1 pg/mL is equal to 0.1 ng/dL.
- 1 μg/dL is equal to 100 ng/dL.




## Problems/Concerns

### Questions on data display

- Would it be better to state cores using a within-subject measurement like proportion of core positive (median, IQR).
- Should we categorize medications?
- Should we remov
- Should swimmer plots be indexed by age, dx date or year?

### Todo

- Redo genomic analyses started by Irbaz.
- Basic survival analyses (starting with OS).


### Missing marker units on some results

This was shared with Jennifer Hoppe and Mike Fiandalo at AACR in April 2023:

```{r, echo = T, include = T}
dft_tm_miss_units <- dft_tm %>%
  filter(tm_type %in% c("PSA", "Testosterone")) %>%
  filter(is.na(tm_result_units))
dft_tm_miss_units %>%
  mutate(num_result_exists = !is.na(tm_num_result)) %>%
  summarize(
    n_num_result_exists = sum(num_result_exists),
    prop_num_result_exists = mean(num_result_exists)
  )
```




```{r, echo = F, include = F}

# This block can be deleted later on.  Output to resolve a potential error in data.

# dft_tm_miss_units %>%
#   arrange(record_id) %>%
#   readr::write_csv(
#     x = ., 
#     file = here("data", "tumor_marker_missing_units.csv"),
#     na = ""
#   )
# 
# library(synapser)
# 
# synLogin()
# synapser::File(here("data", "tumor_marker_missing_units.csv"),
#                parent = "syn51393619") %>%
#   synStore()


```






