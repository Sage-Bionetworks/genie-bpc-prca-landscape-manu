---
title: "GENIE BPC Prostate Cancer - Landscape Report"
author: "Alex Paynter"
date: "Work started April 4, 2023"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, include = F,
                      warning = F, message = F,
                      fig.width = 7, fig.height = 5)
k_dpi <- 150
```

<style type="text/css">
.main-container {
  max-width: 800px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{r}
library(readr)
library(here)
library(dplyr)
library(tidyr)
library(purrr)
library(rlang)
library(magrittr)
library(janitor)
library(stringr)

library(ggplot2)

library(gt)
library(gtsummary)

as_list(here("R", dir(here("R"))))

# Source everything in the "R" folder - just functions, no scripts.
purrr::walk(.x = here("R", dir(here("R"))), .f = source)
```


```{r, warning = T}
read_wrap <- function(p) {
  read_csv(file = here("data-raw", p), show_col_types = F)
}

dft_pt <- read_wrap("patient_level_dataset.csv")
dft_ca_ind <- read_wrap("cancer_level_dataset_index.csv")
dft_med_onc <- read_wrap("med_onc_note_level_dataset.csv")
dft_tm <- read_wrap("tm_level_dataset.csv")
dft_cpt <- read_wrap("cancer_panel_test_level_dataset.csv")

# A few sanity checks on the data:
if ((dft_pt$record_id %>% duplicated %>% any)) {
  stop("Duplicated records in patient level dataset.")
}

if (any(dft_pt$naaccr_sex_code != "Male")) {
  warning("Non-male sex detected for at least one participant (unexpectedly for Prostate cancer)")
}

```


```{r, demo_data_manipulation, include = F}
dft_pt_baseline_sub <- dft_pt %>%
  mutate(
    `Race (primary)` = format_ptlevel_naaccr_race_code_primary(
      naaccr_race_code_primary
    ),
    `Ethnicity` = format_ptlevel_naaccr_ethnicity_code(
      naaccr_ethnicity_code
    )) %>%
  select(record_id, 
         Institution = institution,
         `Race (primary)`,
         `Ethnicity`)


dft_ca_ind_baseline_sub <- dft_ca_ind %>%
  mutate(
    ca_dx_how = format_ca_dx_how(ca_dx_how),
    ca_hist_adeno_squamous = format_ca_hist_adeno_squamous(ca_hist_adeno_squamous),
    stage_dx = format_stage_dx(stage_dx),
    ca_path_n_stage = format_ca_path_n_stage(ca_path_n_stage)
  ) %>%
  select(
    record_id,
    `Age at dx (years)` = dob_ca_dx_yrs,
    `Stage at dx` = stage_dx,
    `Source of dx` = ca_dx_how,
    `Histology` = ca_hist_adeno_squamous, # at dx?
    `Pathologic N Stage` = ca_path_n_stage # describes spread to lymph nodes
  ) 


dft_demo <- full_join(dft_pt_baseline_sub,
                      dft_ca_ind_baseline_sub,
                      by = "record_id") 

```

### R1.1a: Baseline characteristics

For most analyses, especially survival, the timing of observations is critical.  Here we have separated baseline characteristics (Table R1.1) and characteristics which could represent a first post-baseline observation (Table R1.2).  After speaking with Jennifer Hoppe at AACR, my understanding is that for all prostate specific variables in the cancer diagnosis dataset, curators were instructed to curate from time of diagnosis through completion of surgeries in the first course of treatment.  Therefore, those variables are in Table R1.2 unless we can confirm they were exclusively measured at baseline.


```{r, tab_r1_1a, include = T}
dft_demo %>%
  select(-record_id) %>%
  gtsummary::tbl_summary(data = .)
```

### R1.1b: Baseline characteristics by site

Observations:

- MSK, UHN and VICC have more late stage cancers (about 50%).  DFCI has more Stage II/III cancers.
- Several variables are 100% unknown at UHN:  Histology and Ethnicity.

```{r, tab_r1_1b, include = T}
dft_demo %>%
  select(-record_id) %>%
  gtsummary::tbl_summary(data = ., by = Institution)
```









```{r}


dft_ca_ind_post_baseline <- dft_ca_ind %>%
  mutate(
    ce_num = format_cores(ca_pros_num_cores),
    cp_num = format_cores(ca_pros_num_corespos),
    clin_gleason = format_gleason(ca_pros_clin_gscore)
  ) %>%
  select(record_id, ce_num, cp_num, clin_gleason)



dft_med_onc_post_baseline <- dft_med_onc %>%
  group_by(record_id) %>%
  arrange(md_visit_number) %>%
  # filter down to the first determination made.
  #  That is, we will ignore rows with "Not stated in the Impression/Plan", unless that is the only type of entry ever
  #  Made for the patient.
  filter(str_detect(md_pca_status, "(CRPC)|(HSPC)") | 1:n() == n()) %>%
  slice(1) %>%
  ungroup %>%
  # First castration-resistance determination:
  mutate(first_cast_det = if_else(str_detect(md_pca_status, "Not stated in"),
                              "Never stated in Impression/Plan",
                              md_pca_status),
         first_cast_det = factor(first_cast_det)) %>%
  select(record_id,
         first_cast_det)

# Dominant units for PSA are ng/mL
# Dominant units for Testosterone are ng/dL

tm_missing_units <- dft_tm %>%
  filter(tm_type %in% c("PSA", "Testosterone")) %>%
  group_by(tm_type) %>%
  filter(is.na(tm_result_units) & !is.na(tm_num_result)) %>%
  summarize(n = n())

# # Visual check on the unit conversions if desired.  Just looking for
# good overall overlap between converted and non-converted units.
# dft_tm %>%
#   psa_test_unit_convert() %>%
#   mutate(converted_unit = tm_result_units != tm_result_units_conv) %>%
#   ggplot(., aes(x = 1, y = tm_num_result_conv, color = converted_unit)) + 
#   geom_jitter(width = 1, height = 0) + 
#   scale_y_log10() + 
#   facet_wrap(vars(tm_type))

dft_tm_post_baseline <- dft_tm %>%
   psa_test_unit_convert() %>%
  # filter down to results at or on diagnosis.
  # Importantly there are psa/test values available before diagnosis for
  #   many participants.
  filter(dx_tm_days >= 0) %>% 
  group_by(record_id, tm_type) %>%
  arrange(dx_tm_days) %>%
  slice(1) %>%
  ungroup() %>% 
  select(record_id, tm_type, tm_num_result_conv, tm_result_units_conv) 

# kind of a hacky check:  the resulting tibble will be 2 rows and 3 columns if there are 2 analytes with one unit each.
tm_unit_conv_check <- dft_tm_post_baseline %>% 
  tabyl(tm_type, tm_result_units_conv) %>% 
  dim
if (!all.equal(tm_unit_conv_check,c(2,3))) {
  cli::abort("Unit conversion problem.")
}

dft_tm_post_baseline %<>% 
  select(-tm_result_units_conv) %>%
  tidyr::pivot_wider(
    names_from = "tm_type",
    values_from = "tm_num_result_conv"
  ) %>%
  rename(
    `PSA (ng/mL)` = PSA,
    `Testosterone (ng/dL)` = Testosterone
  )

# dft_ca_ind_post_baseline %>% count(record_id) %>% arrange(desc(n))
# dft_med_onc_post_baseline %>% count(record_id) %>% arrange(desc(n))
# dft_ca_ind_post_baseline %>% count(record_id) %>% arrange(desc(n))


dft_post_baseline <- full_join(
  dft_ca_ind_post_baseline,
  dft_med_onc_post_baseline,
  by = "record_id"
) %>%
  full_join(
    .,
    dft_tm_post_baseline,
    by = "record_id"
  )

dft_post_baseline %<>%
  left_join(
    ., 
    select(dft_pt, record_id, institution),
    by = "record_id"
  )

dfp_post_baseline <- dft_post_baseline %>%
  select(
    record_id,
    Institution = institution,
    `Prostate cores examined` = ce_num,
    `Prostate cores positive` = cp_num,
    `Clinical Gleason score` = clin_gleason,
    `Castration sensitivity (first)` = first_cast_det,
    `PSA (ng/mL)`, 
    `Testosterone (ng/dL)`
  )
  
  



```


### R1.2a: First observed characteristics (post-dx)

Testosterone and PSA were recorded under a number of units.  We assumed the following conversion factors:

**PSA** 

- 1 ng/dL is equal to 0.01 ng/mL.
- 1 μg/dL is equal to 1 ng/mL.
- PSA levels in nmol/L (2 results) were discarded as it seemed exceptionally rare to state PSA this way (but common for testosterone, so an easy mistake to make).
- Any PSA results with missing units were discarded (n = `r pull(filter(tm_missing_units, tm_type %in% "PSA"), n)`)

**Testosterone** 

- 1 ng/mL is equal to 100 ng/dL.
- 1 nmol/L is equal to 28.81 ng/dL.
- 1 pg/mL is equal to 0.1 ng/dL.
- 1 μg/dL is equal to 100 ng/dL.

For each characteristic here, the first determinate observation after diagnosis is stated if more than one observation exists in the data.


```{r, tab_r1_2a, include = T}
dfp_post_baseline %>%
  select(-c(record_id, Institution)) %>%
  gtsummary::tbl_summary(data = .)
```

### R1.2b: Post-baseline characteristics by site

Observations on the table:

- DFCI has more participants with low first observed Gleason scores.  This is consistent with the early stage observation from the previous table.
- MSK has more participants with HSPC on the first observation, which seems inconsistent with higher average stage.  This may indicate a scoring difference on HSPC/CRPC between institutions.

```{r, tab_r1_2b, include = T}
dfp_post_baseline %>%
  select(-record_id) %>%
  gtsummary::tbl_summary(data = ., by = Institution)
```







```{r}
set.seed(189)
random_pt_subset <- dft_pt$record_id %>% 
  unique %>% 
  sample(x = ., size = 40, replace = F)

dft_cast_block <- make_cast_status_block(
  dft_med_onc, 
  dft_ca_ind, 
  remove_hspc_after_crpc = T)

dft_event <- make_event_df(
  ca_ind_dat = dft_ca_ind,
  cast_block_dat = dft_cast_block
)

gg_swim_cast_dx <- plot_swim_block_status(
  #line_pal = c("gray80", "#ddaa33", "#bb5566"),
  block_dat = dft_cast_block,
  block_var = "md_cast_status_f",
  event_dat = dft_event,
  event_var = "event",
  pt_subset = random_pt_subset
)

ggsave(filename = here("fig", "R1.5a_swim_cast_dx.png"),
       plot = gg_swim_cast_dx,
       width = 7, height = 5, dpi = k_dpi)
```

### R1.5a: Swimmer plot, CRPC/HSPC, from dx

**General note for swimmer plots** For the moment we're using a random subset of participants.  When we decide on a final set of plots for the manuscript, it may make sense to choose a representative cohort based on what we're showing.

We have removed indications of hormone-sensitive prostate cancer in the data which occur after designations of castrate-resistant prostate cancer.  This is based on personal communications with our clinical collaborators, who shared that once someone is considered castrate-sensitive they retain that status for life.

```{r, include = T}
gg_swim_cast_dx
```











```{r}
dft_cast_block_by_age <- left_join(
  dft_cast_block,
  (dft_ca_ind %>% select(record_id, age_dx)),
  by = "record_id"
) %>%
  mutate(
    across(
      .cols = c(dx_block_start, dx_block_end, tt_os_dx_yrs),
      .fn = (function(x) x + age_dx)
    )
  ) 

dft_event_by_age <- left_join(
  dft_event,
  (dft_ca_ind %>% select(record_id, age_dx)),
  by = "record_id"
) %>%
  mutate(t_yrs = t_yrs + age_dx)

gg_swim_cast_age <- plot_swim_block_status(
  block_dat = dft_cast_block_by_age,
  block_var = "md_cast_status_f",
  event_dat = dft_event_by_age,
  event_var = "event",
  pt_subset = random_pt_subset
)

gg_swim_cast_age <- gg_swim_cast_age + 
  scale_x_continuous(name = "Age (years)")

ggsave(filename = here("fig", "R1.5b_swim_cast_age.png"),
       plot = gg_swim_cast_age,
       width = 7, height = 5, dpi = k_dpi)

```

### R1.5b: Swimmer plot, CRPC/HSPC, by Age

```{r, include = T}
gg_swim_cast_age 
```









```{r}
dft_dmet_block <- make_dmet_status_block(ca_ind_dat = dft_ca_ind)

gg_swim_dmet_dx <- plot_swim_block_status(
  #line_pal = c("gray80", "#ddaa33", "#bb5566"),
  block_dat = dft_dmet_block,
  block_var = "dmet_status",
  event_dat = dft_event,
  event_var = "event",
  pt_subset = random_pt_subset,
  line_pal = c("#6699cc", "#ee99aa")
)

ggsave(filename = here("fig", "R1.5c_swim_dmet_dx.png"),
       plot = gg_swim_dmet_dx,
       width = 7, height = 5, dpi = k_dpi)
```

### R1.5c: Swimmer plot, Distant metastasis status, from dx

```{r, print_swim_dmet_dx, include = T}
gg_swim_dmet_dx
```









## Problems/Concerns

### Questions on data display

- Would it be better to state cores using a within-subject measurement like proportion of core positive (median, IQR).
- Should we categorize medications?
- Should swimmer plots be indexed by age, dx date or year?


### Missing marker units on some results

This was shared with Jennifer Hoppe and Mike Fiandalo at AACR in April 2023:

```{r, echo = T, include = T}
dft_tm_miss_units <- dft_tm %>%
  filter(tm_type %in% c("PSA", "Testosterone")) %>%
  filter(is.na(tm_result_units))
dft_tm_miss_units %>%
  mutate(num_result_exists = !is.na(tm_num_result)) %>%
  summarize(
    n_num_result_exists = sum(num_result_exists),
    prop_num_result_exists = mean(num_result_exists)
  )
```




```{r, echo = F, include = F}

# This block can be deleted later on.  Output to resolve a potential error in data.

# dft_tm_miss_units %>%
#   arrange(record_id) %>%
#   readr::write_csv(
#     x = ., 
#     file = here("data", "tumor_marker_missing_units.csv"),
#     na = ""
#   )
# 
# library(synapser)
# 
# synLogin()
# synapser::File(here("data", "tumor_marker_missing_units.csv"),
#                parent = "syn51393619") %>%
#   synStore()


```






